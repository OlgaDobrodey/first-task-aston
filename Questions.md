1. **Почему нет метода iterator.add() чтобы добавить элементы в коллекцию?**

   - Единственная задача итератора это перебор коллекции. Каждая коллекция имеет метод add() которым вы можете
     воспользоваться. Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и
     неупорядоченными, и метод add() при этом должен быть устроен по разному.

2. **Чем отличается методы offer() и add() в коллекции Queue**

   - Метод offer() вставляет элемент в очередь, если это не удалось — возвращает ***false***. Этот метод отличается от
     метода add() интерфейса Collection тем,
   - что метод add() может не выполнить добавление элемента только с использованием ***unchecked*** исключения.]

3. **Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?**

   - Вернется из блока finally.
       - public static String method() {

         try { return "SomeString";}

         catch(Exception ex) { return "Catch message";}

         finally { return "Finally message";}

     //Вывод
     Finally message

4. **Что будет, если в Map положить два значения с одинаковым ключом?**

   - Последнее значение перезапишет предыдущее.

5. **Как получить синхронизированную коллекцию из не синхронизированной?**

   - Collections.synchronizedList(list);
     Collections.synchronizedSet(set);
     Collections.synchronizedMap(map);

6. **Как получить коллекцию только для чтения?**

   - Collections.unmodifiableList(list);
     Collections.unmodifiableSet(set);
     Collections.unmodifiableMap(map);
   - Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами
     внутри.

7. **Почему Map не наследуется от Collection**

   - Они не совместимы, т.к. созданы для различных структур данных. Map использует пару ключ-значение.

8. **Какое худшее время работы метода contains() для элемента, который есть в LinkedList?**

   - O(N). Время поиска элемента линейно пропорционально количеству элементов в списке.

9. **В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?**
   - Размер массива elementData представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.

10. **Что будет, если добавлять элементы в TreeSet по возрастанию?**

    - В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.
